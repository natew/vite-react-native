---
title: Utility Functions
---

All functions listed below are exported directly by `one`.

### redirect

A function that takes two arguments: a string `path`, and a number `status`.

```tsx
import { redirect } from 'one'

export function redirectToLogin() {
  return redirect('/login')
}
```

It accepts relative paths by using the [`getURL`](#getURL) helper internally.

On the server (including in loaders) it returns a `Response.redirect` object. On the client it calls `router.navigate` and returns void.

### getURL

A function that takes no arguments and returns a string of the current URL of the running application on client or server.

For example, in dev-mode by default this would be a string of `http://127.0.0.1:8081`. In non-development environments you will need to set `process.env.ONE_SERVER_URL` to your production URL with no trailing `/`.

### isResponse

One uses `Request`/`Response` type objects for API routes, but for some environments doing an `instanceof Response` can fail, `isResponse` takes any value and returns true if it is a Response-like object. Useful for API utility functions.

### href

A simple function allows for creating typed route strings. It's a type-level only check, at runtime it only validates that it is a string.

```tsx
import { href } from 'one'

const postPageLink = href(`/post/hello-world`) // will type error if invalid Href
```

### setClientData and getClientData

<Status is="developing" />

Experimental API, currently only supported on the web.

Allows passing arbitrary JSON-like data from the server to the client. `setClientData` can be called inside
loaders or anywhere in your app during render on the server side. `getClientData` can only be called on the client,
and will access the data passed from the server.

The main difference from loaders is that you can set this data from anywhere, anytime during the server render. It lets you avoid loaders altogether for one-off hooks.

```tsx fileName=app/index.tsx
import { setClientData, useLoader } from 'one'

export default () => {
  const loadedData = useLoader(loader)
  const hookData = useHookData()

  // ...
}

// prefer loaders in your app when possible, easier to keep data local and typed:
export const loader = async () => {
  return {
    data: await fetchLoaderData()
  }
}

// for libraries, or times where you want to pass data to the client side from hooks
const useHookData = () => {
  const id = useId()

  if (typeof window === 'undefined') {
    const data = loadDataWithSuspense()
    setClientData(id, data)
    return data
  }

  // this will be available on first render on the client
  return getClientData(id)
}
```


